procs {
  Drawing [_lb FileName DrawingName Children Connections _rb] = ‛«Children»’

  Children [_key _colon _lb Child+ _rb] = ‛«Child»’
  Connections [_key _colon _lb Object+ _rb] = ‛’

  Child [_lb _key _colon Value _keyid _colon2 integer _rb] = ‛«Value»’

  Key [dq1 s dq2] = ‛«dq1»«s»«dq2»’

  NamedObject [string _colon Object] = ‛’
  NamedValue [string _colon Value] = ‛’

  KeyedString [_k _colon string] = ‛’

  Object [_lb NamedValue+ _rb] = ‛«NamedValue»’
  Array [_lb x+ _rb] = ‛«x»’
  CodeDescriptor [_mark procname code] =
   ‛\n«procname» :: proc (name: string, owner : ^zd.Eh) -> ^zd.Eh {
	handler :: proc (eh: ^zd.Eh, msg: ^zd.Message) {«code»
	}
	instance_name := zd.gensym ("«procname»")
	return zd.make_leaf (instance_name, owner, nil, handler)
    }’

  PredicateDescriptor [_mark code] ‛«_.pushNewPredicateName ()»’ =
   ‛\n«_.topPredicateName ()» :: proc (name: string, owner : ^zd.Eh) -> ^zd.Eh {
	handler :: proc (eh: ^zd.Eh, msg: ^zd.Message) {
	  if («code») {
            zd.send (eh=eh, port="yes", datum=zd.new_datum_bang (), causingMessage=msg)
          } else {
            zd.send (eh=eh, port="no", datum=zd.new_datum_bang (), causingMessage=msg)
          }
	}
	instance_name := zd.gensym ("«_.topPredicateName ()»")
	return zd.make_leaf (instance_name, owner, nil, handler)
    }«_.popPredicateName ()»’

  string [dq1 notDQ* dq2] = ‛’
  anychar_escaped [_bs any] = ‛’
  anychar_other [any] = ‛’

  procname [s] = ‛«s.replaceAll (" ", "_")»’
  escstuff [_lb cs+ _rb] = ‛«decodeURIComponent (cs)»’
}
